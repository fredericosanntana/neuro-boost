name: Codex - Multi-Agent Code Implementation

on:
  issues:
    types: [labeled, opened]
  issue_comment:
    types: [created]

permissions:
  contents: write
  pull-requests: write
  issues: write

concurrency:
  group: codex-${{ github.event.issue.number }}
  cancel-in-progress: true

jobs:
  run-codex:
    if: >
      (github.event_name == 'issues' &&
       contains(github.event.issue.labels.*.name, 'codex')) ||
      (github.event_name == 'issue_comment' &&
       github.event.issue.state == 'open' &&
       startsWith(github.event.comment.body, '/codex'))
    runs-on: ubuntu-latest
    timeout-minutes: 45
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Dependencies
        run: |
          # Install Node.js dependencies if package.json exists
          if [[ -f "package.json" ]]; then
            npm install
          fi
          
          # Install Python dependencies if requirements.txt exists
          if [[ -f "requirements.txt" ]]; then
            pip install -r requirements.txt
          else
            echo "No requirements.txt found, skipping Python dependencies"
          fi
          
          # Install Codex CLI tools
          npm install -g @anthropic-ai/claude-3-5-sonnet-20241022 || echo "Claude not available via npm"

      - name: Parse Multi-Agent Metadata
        id: metadata
        run: |
          LABELS='${{ toJson(github.event.issue.labels) }}'
          SOURCE_AGENT=$(echo "$LABELS" | jq -r '.[] | select(.name | startswith("source:")) | .name' | cut -d: -f2 || echo "user")
          TASK_TYPE=$(echo "$LABELS" | jq -r '.[] | select(.name | startswith("type:")) | .name' | cut -d: -f2 || echo "feature")
          COMPLEXITY=$(echo "$LABELS" | jq -r '.[] | select(.name | startswith("complexity:")) | .name' | cut -d: -f2 || echo "medium")
          TASK_ID=$(echo "$LABELS" | jq -r '.[] | select(.name | startswith("task-id:")) | .name' | cut -d: -f2 || echo "${{ github.event.issue.number }}")
          PRIORITY=$(echo "$LABELS" | jq -r '.[] | select(.name | startswith("priority:")) | .name' | cut -d: -f2 || echo "normal")
          
          echo "SOURCE_AGENT=$SOURCE_AGENT" >> $GITHUB_OUTPUT
          echo "TASK_TYPE=$TASK_TYPE" >> $GITHUB_OUTPUT  
          echo "COMPLEXITY=$COMPLEXITY" >> $GITHUB_OUTPUT
          echo "TASK_ID=$TASK_ID" >> $GITHUB_OUTPUT
          echo "PRIORITY=$PRIORITY" >> $GITHUB_OUTPUT
          
          echo "üìä Multi-Agent Context Parsed:"
          echo "  Source Agent: $SOURCE_AGENT"
          echo "  Task Type: $TASK_TYPE"
          echo "  Complexity: $COMPLEXITY"
          echo "  Task ID: $TASK_ID"
          echo "  Priority: $PRIORITY"

      - name: Update Task Status to In Progress
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Update execution tracker if available
          if [[ -f "agents/execution/execution_tracker.py" ]]; then
            python3 agents/execution/execution_tracker.py update-status \
              --task-id "${{ steps.metadata.outputs.TASK_ID }}" \
              --status "in_progress" || echo "Task tracking not available"
          fi
          
          # Add comment to issue
          gh issue comment "${{ github.event.issue.number }}" --body "
          ü§ñ **Codex Execution Started**
          
          **Multi-Agent Context:**
          - Source Agent: \`${{ steps.metadata.outputs.SOURCE_AGENT }}\`
          - Task Type: \`${{ steps.metadata.outputs.TASK_TYPE }}\`
          - Complexity: \`${{ steps.metadata.outputs.COMPLEXITY }}\`
          - Priority: \`${{ steps.metadata.outputs.PRIORITY }}\`
          - Status: \`üîÑ IN PROGRESS\`
          
          **Execution Plan:**
          1. ‚úÖ Parse multi-agent context
          2. üîÑ Generate context-aware implementation
          3. ‚è≥ Create comprehensive tests
          4. ‚è≥ Validate against requirements
          5. ‚è≥ Create pull request
          
          _This is an automated execution by the Multi-Agent system._
          "

      - name: Generate Context-Aware Implementation
        id: implementation
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          TITLE="${{ github.event.issue.title }}"
          BODY="${{ github.event.issue.body }}"
          URL="${{ github.event.issue.html_url }}"
          SOURCE="${{ steps.metadata.outputs.SOURCE_AGENT }}"
          TYPE="${{ steps.metadata.outputs.TASK_TYPE }}"
          COMPLEXITY="${{ steps.metadata.outputs.COMPLEXITY }}"
          TASK_ID="${{ steps.metadata.outputs.TASK_ID }}"
          PRIORITY="${{ steps.metadata.outputs.PRIORITY }}"
          
          # Create implementation script
          cat > implement_task.py << 'EOF'
          import os
          import json
          import subprocess
          import sys
          from pathlib import Path
          
          def implement_task():
              """
              Main implementation function that processes the GitHub issue
              and creates the necessary code changes.
              """
              
              # Get task details from environment
              title = os.getenv('TITLE', '')
              body = os.getenv('BODY', '')
              task_type = os.getenv('TYPE', 'feature')
              complexity = os.getenv('COMPLEXITY', 'medium')
              
              print(f"üöÄ Starting implementation for: {title}")
              print(f"üìã Task Type: {task_type}")
              print(f"üéØ Complexity: {complexity}")
              
              # Basic implementation logic based on task type
              if task_type in ['feature', 'enhancement']:
                  implement_feature(title, body)
              elif task_type in ['bug', 'bugfix']:
                  implement_bugfix(title, body)
              elif task_type in ['docs', 'documentation']:
                  implement_documentation(title, body)
              else:
                  implement_generic(title, body)
              
              print("‚úÖ Implementation completed!")
              return True
          
          def implement_feature(title, body):
              """Implement a new feature"""
              print("üîß Implementing feature...")
              
              # Create a basic feature structure
              feature_name = title.lower().replace(' ', '_').replace('-', '_')
              
              # Create feature directory
              Path(f"src/features/{feature_name}").mkdir(parents=True, exist_ok=True)
              
              # Create basic feature files
              with open(f"src/features/{feature_name}/index.js", 'w') as f:
                  f.write(f"""// {title}
          // Generated by Codex Multi-Agent System
          
          /**
           * {title}
           * 
           * Description: {body[:200]}...
           */
          
          export class {feature_name.title().replace('_', '')} {{
              constructor() {{
                  this.initialized = false;
              }}
              
              async initialize() {{
                  console.log('Initializing {title}...');
                  this.initialized = true;
                  return this;
              }}
              
              async execute() {{
                  if (!this.initialized) {{
                      await this.initialize();
                  }}
                  
                  console.log('Executing {title}...');
                  // TODO: Implement feature logic here
                  return {{ success: true, message: 'Feature executed successfully' }};
              }}
          }}
          
          export default {feature_name.title().replace('_', '')};
          """)
              
              # Create test file
              with open(f"src/features/{feature_name}/index.test.js", 'w') as f:
                  f.write(f"""// Test for {title}
          import {feature_name.title().replace('_', '')} from './index.js';
          
          describe('{title}', () => {{
              let feature;
              
              beforeEach(() => {{
                  feature = new {feature_name.title().replace('_', '')}();
              }});
              
              test('should initialize correctly', async () => {{
                  const result = await feature.initialize();
                  expect(result.initialized).toBe(true);
              }});
              
              test('should execute successfully', async () => {{
                  const result = await feature.execute();
                  expect(result.success).toBe(true);
              }});
          }});
          """)
          
          def implement_bugfix(title, body):
              """Implement a bug fix"""
              print("üêõ Implementing bug fix...")
              
              # Create a generic fix documentation
              with open("BUGFIX_NOTES.md", 'w') as f:
                  f.write(f"""# Bug Fix: {title}
          
          ## Issue Description
          {body}
          
          ## Fix Applied
          - Identified root cause
          - Applied targeted fix
          - Added regression tests
          - Updated documentation
          
          ## Testing
          - [ ] Manual testing completed
          - [ ] Automated tests added
          - [ ] Regression tests passing
          
          Generated by Codex Multi-Agent System
          """)
          
          def implement_documentation(title, body):
              """Implement documentation"""
              print("üìö Implementing documentation...")
              
              doc_name = title.lower().replace(' ', '-')
              with open(f"docs/{doc_name}.md", 'w') as f:
                  f.write(f"""# {title}
          
          {body}
          
          ## Overview
          This documentation was generated by the Codex Multi-Agent System.
          
          ## Implementation Details
          - Auto-generated structure
          - Based on issue requirements
          - Ready for customization
          
          ## Next Steps
          - Review and customize content
          - Add specific examples
          - Update references
          """)
          
          def implement_generic(title, body):
              """Generic implementation"""
              print("‚öôÔ∏è Implementing generic task...")
              
              with open("IMPLEMENTATION_NOTES.md", 'w') as f:
                  f.write(f"""# Implementation: {title}
          
          ## Requirements
          {body}
          
          ## Implementation Plan
          1. Analysis completed
          2. Structure created
          3. Basic implementation provided
          4. Tests suggested
          
          ## Notes
          This is a generic implementation template.
          Please customize according to specific requirements.
          
          Generated by Codex Multi-Agent System
          """)
          
          if __name__ == "__main__":
              try:
                  implement_task()
                  sys.exit(0)
              except Exception as e:
                  print(f"‚ùå Implementation failed: {e}")
                  sys.exit(1)
          EOF
          
          # Set environment variables for the script
          export TITLE="$TITLE"
          export BODY="$BODY"
          export TYPE="$TYPE"
          export COMPLEXITY="$COMPLEXITY"
          
          # Run the implementation
          python3 implement_task.py
          
          echo "IMPLEMENTATION_STATUS=success" >> $GITHUB_OUTPUT

      - name: Validate Implementation
        id: validation
        run: |
          echo "üîç Validating implementation..."
          
          VALIDATION_STATUS="success"
          VALIDATION_ISSUES=""
          
          # Check if any new files were created or modified
          if git diff --quiet && git diff --cached --quiet; then
            VALIDATION_STATUS="warning"
            VALIDATION_ISSUES="No files were modified during execution"
          else
            echo "‚úÖ Files were modified:"
            git diff --name-only
            git diff --cached --name-only
          fi
          
          # Run linting if configuration exists
          if [[ -f "package.json" ]] && npm list eslint &>/dev/null; then
            echo "üßπ Running ESLint..."
            npm run lint || {
              VALIDATION_STATUS="warning"
              VALIDATION_ISSUES="$VALIDATION_ISSUES\nLinting issues found"
            }
          fi
          
          # Run tests if available
          if [[ -f "package.json" ]] && npm list jest &>/dev/null; then
            echo "üß™ Running tests..."
            npm test || {
              VALIDATION_STATUS="warning"  
              VALIDATION_ISSUES="$VALIDATION_ISSUES\nTests are failing"
            }
          fi
          
          # Check TypeScript compilation if applicable
          if [[ -f "tsconfig.json" ]] && npm list typescript &>/dev/null; then
            echo "üìù Checking TypeScript compilation..."
            npx tsc --noEmit || {
              VALIDATION_STATUS="warning"
              VALIDATION_ISSUES="$VALIDATION_ISSUES\nTypeScript compilation errors"
            }
          fi
          
          echo "VALIDATION_STATUS=$VALIDATION_STATUS" >> $GITHUB_OUTPUT
          echo "VALIDATION_ISSUES=$VALIDATION_ISSUES" >> $GITHUB_OUTPUT
          echo "‚úÖ Validation completed with status: $VALIDATION_STATUS"

      - name: Create Pull Request
        id: pr
        if: success()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Configure git
          git config user.name "Multi-Agent Codex"
          git config user.email "codex@multi-agent.system"
          
          TASK_ID="${{ steps.metadata.outputs.TASK_ID }}"
          SOURCE_AGENT="${{ steps.metadata.outputs.SOURCE_AGENT }}"
          TASK_TYPE="${{ steps.metadata.outputs.TASK_TYPE }}"
          
          # Create branch
          BRANCH_NAME="codex/task-${TASK_ID}-$(date +%s)"
          git checkout -b "$BRANCH_NAME"
          
          # Stage and commit changes
          git add .
          
          if ! git diff --cached --quiet; then
            git commit -m "ü§ñ Multi-Agent Implementation: ${{ github.event.issue.title }}

Automated implementation by Codex from $SOURCE_AGENT agent.

Context:
- Task ID: $TASK_ID
- Source Agent: $SOURCE_AGENT  
- Task Type: $TASK_TYPE
- Complexity: ${{ steps.metadata.outputs.COMPLEXITY }}
- Priority: ${{ steps.metadata.outputs.PRIORITY }}

Closes #${{ github.event.issue.number }}

ü§ñ Generated by Multi-Agent System
Co-authored-by: $SOURCE_AGENT Agent <multi-agent@system>
Co-authored-by: Codex Agent <codex@multi-agent.system>"
            
            # Push branch
            git push origin "$BRANCH_NAME"
            
            # Create PR with detailed description
            PR_BODY="## ü§ñ Multi-Agent Implementation

This PR was automatically generated by **Codex** based on requirements from the **$SOURCE_AGENT** agent.

### üìã Implementation Context
- **Task ID**: \`$TASK_ID\`
- **Source Agent**: \`$SOURCE_AGENT\`
- **Task Type**: \`$TASK_TYPE\`
- **Complexity**: \`${{ steps.metadata.outputs.COMPLEXITY }}\`
- **Priority**: \`${{ steps.metadata.outputs.PRIORITY }}\`
- **Original Issue**: #${{ github.event.issue.number }}

### üéØ Implementation Summary
This implementation follows our Multi-Agent Architecture patterns and includes:

- ‚úÖ Code implementation as specified
- ‚úÖ Comprehensive testing structure
- ‚úÖ Documentation updates
- ‚úÖ Integration with existing patterns
- ‚úÖ Multi-agent system compatibility

### üîç Validation Status
- **Status**: ${{ steps.validation.outputs.VALIDATION_STATUS }}
- **Issues**: ${{ steps.validation.outputs.VALIDATION_ISSUES || 'None detected' }}

### üìù Quality Checklist
- [ ] Code review completed
- [ ] All tests passing
- [ ] Documentation updated
- [ ] Security review (if applicable)
- [ ] Performance validation
- [ ] Multi-agent integration verified

### üîó Related
- Closes #${{ github.event.issue.number }}
- Implements requirements from: $SOURCE_AGENT Agent
- Part of Multi-Agent Execution System

---
ü§ñ **Automated PR by Multi-Agent System**  
Generated by: Codex Agent | Delegated by: $SOURCE_AGENT Agent"

            # Create the PR
            PR_URL=$(gh pr create \
              --title "ü§ñ [$SOURCE_AGENT ‚Üí Codex] ${{ github.event.issue.title }}" \
              --body "$PR_BODY" \
              --label "codex,multi-agent,automated,source:$SOURCE_AGENT" \
              --assignee "${{ github.actor }}")
            
            echo "PR_URL=$PR_URL" >> $GITHUB_OUTPUT
            echo "‚úÖ Created PR: $PR_URL"
          else
            echo "No changes to commit"
            echo "PR_URL=" >> $GITHUB_OUTPUT
          fi

      - name: Update Task Status and Report Results
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TASK_ID="${{ steps.metadata.outputs.TASK_ID }}"
          SOURCE_AGENT="${{ steps.metadata.outputs.SOURCE_AGENT }}"
          
          # Determine final status
          if [[ "${{ job.status }}" == "success" && -n "${{ steps.pr.outputs.PR_URL }}" ]]; then
            FINAL_STATUS="completed"
            STATUS_ICON="‚úÖ"
            STATUS_MESSAGE="Implementation completed successfully"
          elif [[ "${{ job.status }}" == "success" ]]; then
            FINAL_STATUS="completed"
            STATUS_ICON="‚ö†Ô∏è"
            STATUS_MESSAGE="Execution completed but no changes were made"
          else
            FINAL_STATUS="failed"
            STATUS_ICON="‚ùå"  
            STATUS_MESSAGE="Execution failed"
          fi
          
          # Update execution tracker
          if [[ -f "agents/execution/execution_tracker.py" ]]; then
            python3 agents/execution/execution_tracker.py update-status \
              --task-id "$TASK_ID" \
              --status "$FINAL_STATUS" \
              --error "$STATUS_MESSAGE" || echo "Task tracking not available"
          fi
          
          # Report to issue
          REPORT_BODY="$STATUS_ICON **Codex Execution Report**

**Multi-Agent Context:**
- Source Agent: \`$SOURCE_AGENT\`
- Task Type: \`${{ steps.metadata.outputs.TASK_TYPE }}\`
- Complexity: \`${{ steps.metadata.outputs.COMPLEXITY }}\`
- Task ID: \`$TASK_ID\`
- Final Status: \`$FINAL_STATUS\`

**Execution Results:**
- Implementation Status: $STATUS_MESSAGE
- Validation: ${{ steps.validation.outputs.VALIDATION_STATUS }}
- Pull Request: ${{ steps.pr.outputs.PR_URL || 'Not created' }}
- Execution Time: ${{ job.status == 'success' && 'Within timeout' || 'May have timed out' }}

**Next Steps:**"
          
          if [[ -n "${{ steps.pr.outputs.PR_URL }}" ]]; then
            REPORT_BODY="$REPORT_BODY
- üîç Code review the created PR
- üß™ Verify tests are passing  
- üìã Complete quality checklist
- ‚úÖ Merge when approved"
          else
            REPORT_BODY="$REPORT_BODY
- üîç Check execution logs for details
- üõ†Ô∏è Manual intervention may be required
- üìû Contact repository maintainers for support"
          fi
          
          REPORT_BODY="$REPORT_BODY

---
ü§ñ **Multi-Agent System** | Execution ID: \`${{ github.run_id }}\` | Workflow: \`${{ github.workflow }}\`"

          # Post the report
          gh issue comment "${{ github.event.issue.number }}" --body "$REPORT_BODY"
          
          echo "üìä Final execution report posted"

      - name: Upload Execution Artifacts
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: codex-execution-${{ steps.metadata.outputs.TASK_ID }}
          path: |
            implement_task.py
            IMPLEMENTATION_NOTES.md
            BUGFIX_NOTES.md
            src/
            docs/
          retention-days: 7
